# Operating-System-Project
SAMPLE RUN :
![image](https://github.com/EnasAlzhrani/Operating-System-Project/assets/111420805/6fdb68a3-d2fe-45ca-bff8-b7dcd85d602b)
![image](https://github.com/EnasAlzhrani/Operating-System-Project/assets/111420805/2d588c12-3dd5-4038-ae39-b1df5700bd72)
![image](https://github.com/EnasAlzhrani/Operating-System-Project/assets/111420805/0e87e5c5-f3b0-4337-9cde-2dfe397a1f8e)
![image](https://github.com/EnasAlzhrani/Operating-System-Project/assets/111420805/1e8edd29-33a4-4ffb-80c4-4682308ae826)
![image](https://github.com/EnasAlzhrani/Operating-System-Project/assets/111420805/2bedc207-13ef-4f6c-afcb-c252cb13b552)
![image](https://github.com/EnasAlzhrani/Operating-System-Project/assets/111420805/38d00c69-fab8-49b5-a433-bf8bc3f1344d)
![image](https://github.com/EnasAlzhrani/Operating-System-Project/assets/111420805/e3c5e73a-283e-4862-b157-ac8c5bba7175)
# Evaluating the performance of the scheduling algorithm and  reflecting  on  the  results  of  the  simulation.
SJF is better Turnaround time, waiting time and response time for Q2(FCFS) bigger than Q1(SJF).
# Students may provide suggestions for improving the performance.
 we suggest using round robin method.

# Instructions
•	Run "main Class"

•	Follow the program massages

•	Enter your choice number from 1 to 4

•	If 1 which is the about "processes information " is chosen, enter the number of processes and the priority of process and the arrival time for each one and the burst time for each.

•	If 2 which is "Report detailed information about each process" is chosen, then the program will display the report status including the information about each process and saves it to an output file.

•	If 3 which is " Report the average turnaround time, waiting time, and response time. " Is chosen, then the program will display the report status including average turnaround time, waiting time, and response time and saves it to an output file.

•	If 4 which is "Exit the program "is chosen, the program will terminate.

# Reflection 
The performance is good, but preemptive priority scheduling algorithm will preempt the CPU if the priority of the newly arrived process is higher than the priority of the currently running process there, major problem is no chance for lower priority queues “starvation”.

A solution to the problem of starvation of low-priority processes is aging.
